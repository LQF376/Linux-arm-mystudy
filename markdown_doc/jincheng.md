# 进程

## 1. 进程和程序

### 1.1 链接器和加载器

- 在 mian() 函数执行之前需要执行一段引导代码，最终由引导代码去调用应用程序的main()函数，在编译链接时，链接器会将引导代码链接到我们应用程序，形成可执行文件 
- 加载器：操作系统中的程序，当执行程序时和命令行传参，shell进程会将参数解析传递给加载器，负责将应用程序加载到内存中去执行

### 1.2 程序如何结束

正常终止和异常终止

- main()函数中通过 return 语句返回来终止进程； 
- 应用程序中调用 exit()函数终止进程； 
- 应用程序中调用 \_exit() 或 _Exit() 终止进程； 
- 应用程序中调用 abort() 函数终止进程； 
- 进程接收到一个信号，譬如 SIGKILL 信号。 

### 1.3 注册进程终止处理函数

```c
#include <stdlib.h>

int atexit(void (*function)(void));
function: 指针函数，终止处理函数
返回值： 成功0 失败-1
```

**何为进程**

可执行文件，是一个静态的概念，存放磁盘中，如果可执行文件没有被运行，那它将不会产生什么作用，当它被运行之后，它将会对系统环境产生一定的影响，所以可执行程序的实例就是可执行文件被运行。 

进程是一个动态过程，而非静态文件，它是程序的一次运行过程，当应用程序被加载到内存中运行之后它就称为了一个进程，当程序运行结束后也就意味着进程终止

### 1.4 进程号

进程号是一个正数，用于唯一标识系统中的某一个进程。 

```shell
ps -aux   # 查看所有进程
```

获取自己的进程号

```c
#include <sys/types.h>
#include <unistd.h>

pid_t getpid(void);	// 获取自己的进程号
```

获取父进程的进程号

```c
#include <sys/types.h>
#include <unistd.h>

pid_t getppid(void);
```

## 2. 进程的环境变量

每一个进程都有一组与其相关的环境变量， 这些环境变量以字符串形式存储在一个字符串数组列表中，把这个数组称为环境列表 

```shell
env			# 查看shell 进程的所有环境变量

export LINUX_APP=123456 # 添加 LINUX_APP 环境变量
export -n LINUX_APP # 删除 LINUX_APP 环境变量
```

进程的环境变量是从其父进程中继承过来的 ;环境变量存放在一个字符串数组中，在应用程序中，通过 environ 变量指向它 

```c
extern char **environ; // 申明外部全局变量 environ

for (i = 0; NULL != environ[i]; i++)
	puts(environ[i]);
```

### 2.1 获取指定环境变量

```c
#include <stdlib.h>

char *getenv(const char *name);
name:环境变量名称
返回值：相应环境变量的字符串值； 失败 NULL
```

### 2.2 添加/删除/修改环境变量

```c
/* 1. 添加一个环境变量 */
#include <stdlib.h>

int putenv(char *string);	// 向进程的环境变量数组中添加一个新的环境变量 或者 修改
string：一个字符串指针，指向 name=value 形式的字符串
返回值：成功0  失败 非0
```

### 2.3 添加一个新的环境变量或修改现有环境变量对应的值

```c
#include <stdlib.h>

int setenv(const char *name, const char *value, int overwrite);
name:需要添加或修改的环境变量名称
value:环境变量的值
overwrite： 若参数 name 标识的环境变量已经存在，在参数 overwrite 为 0 的情况下， setenv()函数将不改变现有环境变量的值，也就是说本次调用没有产生任何影响；如果参数 overwrite 的值为非 0，若参数 name 标识的环境变量已经存在，则覆盖，不存在则表示添加新的环境变量。
返回值：成功0 失败-1
```

setenv()函数为形如 name=value 的字符串分配一块内存缓冲区，并将参数 name 和参数 value 所指向的
字符串复制到此缓冲区中，以此来创建一个新的环境变量， 

```shell
NAME=value ./app	# 添加环境变量
```

### 2.4 移除参数 name 标识的环境变量 

```c
#include <stdlib.h>

int unsetenv(const char *name);
```

### 2.5 清空环境变量

```c
environ = NULL;

#include <stdlib.h>
int clearenv(void);
```

## 3. 进程的内存布局(C语言)

- 正文段：可称为代码段，这是 CPU 执行的机器语言指令部分， 
- 初始化数据段：此段称为数据段，包含了显式初始化的全局变量和静态变量，当程序加载到内存中时，从可执行文件中读取这些变量的值。 
- 未初始化数据段：包含了未进行显式初始化的全局变量和静态变量，通常将此段称为 bss 段 ；在程序开始执行之前，系统会将本段内所有内存初始化为 0， 可执行文件并没有为 bss 段变量分配存储空间，在可执行文件中只需记录 bss 段的位置及其所需大小，直到程序运行时，由加载器来分配这一段内存空间。 
- 栈 ：函数内的局部变量以及每次函数调用时所需保存的信息都放在此段中，每次调用函数时，函数传递的实参以及函数返回值等也都存放在栈中。栈是一个动态增长和收缩的段，由栈帧组成，系统会为每个当前调用的函数分配一个栈帧，栈帧中存储了函数的局部变量（所谓自动变量）、实参和返回值 
- 堆 ：可在运行时动态进行内存分配的一块区域，譬如使用 malloc()分配的内存空间，就是从系统堆内存中申请分配的。 

```shell
size testApp 		# 可以查看二进制可执行文件的文本段、数据段、 bss 段的段大小：
```

![1682435272757](https://raw.githubusercontent.com/LQF376/Linux-arm-mystudy/main/markdown_pic/1682435272757.png)

## 4. 进程的虚拟地址空间 

Linux 系统中，采用了虚拟内存管理技术； 在 Linux 系统中，每一个进程都在自己独立的地址空间中运行，在 32 位系统中，每个进程的逻辑地址空间均为 4GB， 这 4GB 的内存空间按照 3:1 的比例进行分配，其中用户进程享有 3G 的空间，而内核独自享有剩下的 1G 空间， 

![1682435390384](https://raw.githubusercontent.com/LQF376/Linux-arm-mystudy/main/markdown_pic/1682435390384.png)

虚拟地址会通过硬件 MMU（内存管理单元）映射到实际的物理地址空间中， 建立虚拟地址到物理地址的映射关系后，对虚拟地址的读写操作实际上就是对物理地址的读写操作， MMU 会将物理地址“翻译”为对应的物理地址

### 4.1 为什么需要引入虚拟地址 

所有的应用程序访问的内存地址就是实际的物理地址， 所以要将所有应用程序加载到内存中， 会出现问题：

- 当多个程序需要运行时，必须保证这些程序用到的内存总量要小于计算机实际的物理内存的大小 
- 内存使用效率低。内存空间不足时，就需要将其它程序暂时拷贝到硬盘中，然后将新的程序装入内存。然而由于大量的数据装入装出，内存的使用效率就会非常低 
- 进程地址空间不隔离。 由于程序是直接访问物理内存的，所以每一个进程都可以修改其它进程的内存数据， 甚至修改内核地址空间中的数据， 
- 无法确定程序的链接地址。 程序运行时，链接地址和运行地址必须一致，否则程序无法运行！ 

引入了虚拟地址机制， 程序访问存储器所使用的逻辑地址就是虚拟地址，通过逻辑地址映射到真正的物理内存上。  所有应用程序运行在自己的虚拟地址空间中， 使得进程的虚拟地址空间和物理地址空间隔离开来； 优点：

- 进程与进程、进程与内核相互隔离。  
- 在某些应用场合下，两个或者更多进程能够共享内存。因为每个进程都有自己的映射表，可以让不同进程的虚拟地址空间映射到相同的物理地址空间中。通常，共享内存可用于实现进程间通信。   
- 便于实现内存保护机制。 
- 编译应用程序时，无需关心链接地址。 

## 5. 创建子进程

提高了系统的并发性（即同时能够处理更多的任务或请求，多个进程在宏观上实现同时运行）。 

```c
#include <unistd.h>

pid_t fork(void);
返回值
	父进程中返回子进程的 PID， 失败 -1
	子进程中返回值是 0；
```

子进程是父进程的一个副本， 譬如子进程拷贝了父进程的数据段、堆、栈以及继承了父进程打开的文件描述符，父进程与子进程并不共享这些存储空间，这是子进程对父进程相应部分存储空间的完全复制，执行 fork()之后，每个进程均可修改各自的栈数据以及堆段中的变量，而并不影响另一个进程。 

虽然子进程是父进程的一个副本，但是对于程序代码段（文本段）来说， 两个进程执行相同的代码段，因为代码段是只读的， 也就是说父子进程共享代码段，在内存中只存在一份代码段数据。 

### 5.1 关于子进程

子进程被创建出来之后，便是一个独立的进程，拥有自己独立的进程空间，系统内唯一的进程号，拥有自己独立的 PCB（进程控制块） ，子进程会被内核同等调度执行，参与到系统的进程调度中。 

### 父、 子进程间的文件共享 

调用 fork()函数之后，子进程会获得父进程所有文件描述符的副本，意味着父、子进程对应的文件描述符均指向相同的文件表

![1682435999018](https://raw.githubusercontent.com/LQF376/Linux-arm-mystudy/main/markdown_pic/1682435999018.png)

子进程拷贝了父进程的文件描述符表，使得父、子进程中对应的文件描述符指向了相同的文件表， 也意味着父、子进程中对应的文件描述符指向了磁盘中相同的文件，因而这些文件在父、子进程间实现了共享，譬如，如果子进程更新了文件偏移量，那么这个改变也会影响到父进程中相应文件描述符的位置偏移量。 

fork之后，父进程和子进程都去打开同一个文件，不会影响各自的文件表，偏移量不共享，因为父、子进程的这两个文件描述符分别指向的是不同的文件表，意味着它们有各自的文件偏移量， 

fork两大用途：

- 父进程希望子进程复制自己，使父进程和子进程同时执行不同的代码段。 
- 一个进程要执行不同的程序。 调用 exec 族函数来实现 ，去执行另一个程序的main

### vfork 系统调用

```
#include <sys/types.h>
#include <unistd.h>

pid_t vfork(void);
```

使用 fork()系统调用的代价是很大的，它复制了父进程中的数据段和堆栈段中的绝大部分内容，这将会消耗比较多的间， 效率会有所降低，而且太浪费；当 fork()函数之后子进程通常会调用 exec 函数， 使得子进程不再执行父程序中的代码段，而是执行新程序的代码段， 从新程序的 main 函数开始执行、 并为新程序重新初始化其数据段、堆段、栈段等； 

vfork()是为子进程立即执行 exec()新的程序而专门设计的 

- vfork()保证子进程先运行， 子进程调用 exec 之后父进程才可能被调度运行 
- vfork()与 fork()一样都创建了子进程，但 vfork()函数并不会将父进程的地址空间完全复制到子进程中，因为子进程会立即调用 exec（或  _ exit） ，于是也就不会引用该地址空间的数据。不过在子进程调用 exec 或_exit 之前，它在父进程的空间中运行、 子进程共享父进程的内存。（子进程会改父进程的东西） 

### 进程的诞生与终止 

进程号为 1 的进程便是所有进程的父进程，通常称为 init 进程，它是 Linux 系统启动之后运行的第一个进程，它管理着系统上所有其它进程， init 进程是由内核启动，因此理论上说它没有父进程。 

**进程的终止 **

异常终止：程序当中调用 abort()函数 ；接收到某些信号导致异常终止 

正常终止：在 main 函数中使用 return 返回；调用 exit()函数结束进程 ；调用 \_exit()或 \_Exit() 函数结束进程 

\_exit() 函数和 exit() 函数的 status 参数定义了进程的终止状态（termination status），父进程可以调用 wait()函数以获取该状态。 

exit()函数会执行的动作如下： 

- 如果程序中注册了进程终止处理函数，那么会调用终止处理函数。 
- 刷新 stdio 流缓冲区。 
- 执行 \_exit() 系统调用。 

**系统调用 wait()可以等待进程的任一子进程终止，同时获取子进程的终止状态信息 **

```
#include <sys/types.h>
#include <sys/wait.h>

pid_t wait(int *status);
status:用于存放子进程终止时的状态信息；NULL 表示不接收子进程终止时的状态信息
返回值：成功 返回子进程对应的进程号  失败 -1
```

- 调用 wait()函数，如果其所有子进程都还在运行，则 wait()会一直阻塞等待，直到某一个子进程终止； 
- 如果进程调用 wait()，但是该进程并没有子进程， 也就意味着该进程并没有需要等待的子进程， 那么 wait()将返回错误，也就是返回-1、并且会将 errno 设置为 ECHILD。 
- 如果进程调用 wait()之前， 它的子进程当中已经有一个或多个子进程已经终止了，那么调用 wait()也不会阻塞。 wait()函数的作用除了获取子进程的终止状态信息之外，更重要的一点，就是回收子进程的一些资源，俗称为子进程“收尸” 

```
/* 宏参数来检查status */
 WIFEXITED(status)：子进程正常终止，则返回 true；
 WEXITSTATUS(status)：返回子进程退出状态，是一个数值，其实就是子进程调用_exit()或 exit()时指定的退出状态； 
 WIFSIGNALED(status)：子进程被信号终止
 WTERMSIG(status)：返回导致子进程终止的信号编号。
 WCOREDUMP(status)：如果子进程终止时产生了核心转储文件，则返回 true； 
```

**waitpid**

```
#include <sys/types.h>
#include <sys/wait.h>

pid_t waitpid(pid_t pid, int *status, int options);
pid:
	>0:表示等待进程号为 pid 的子进程；
	=0:等待与调用进程（父进程）同一个进程组的所有子进程；
	<-1:等待进程组标识符与 pid 绝对值相等的所有子进程；
	=-1:等待任意子进程。
返回值：同wait；options 中包含 WNOHANG 除外
options：位掩码
	 WNOHANG：如果子进程没有发生状态改变（终止、暂停），则立即返回，也就是执行非阻塞等待，可以实现轮训 poll，通过返回值可以判断是否有子进程发生状态改变，若返回值等于 0 表示没有发生改变。
	 WUNTRACED：除了返回终止的子进程的状态信息外，还返回因信号而停止（暂停运行）的子进程状态信息；
	 WCONTINUED：返回那些因收到 SIGCONT 信号而恢复运行的子进程的状态信息。
```

**孤儿进程**

父进程先于子进程结束，也就是意味着，此时子进程变成了一个“孤儿”；所有的孤儿进程都自动成为 init 进程（进程号为 1）的子进程；

**僵尸进程**

子进程先于父进程结束，此时父进程还未来得及给子进程“收尸”，那么此时子进程就变成了一个僵尸进程。 

当父进程调用 wait()（或其变体，下文不再强调）为子进程“收尸”后，僵尸进程就会被内核彻底删除。 

如果父进程并没有调用 wait()函数然后就退出了，那么此时 init 进程将会接管它的子进程并自动调用 wait()， 故而从系统中移除僵尸进程。 

僵尸进程是无法通过信号将其杀死的， 只能杀死僵尸进程的父进程（或等待其父进程终止），这样 init 进程将会接管这些僵尸进程，从而将它们从系统中清理掉！ 

**SIGCHLD 信号 **

父进程收到该信号的两种情况：

- 当父进程的某个子进程终止时，父进程会收到 SIGCHLD 信号 
- 当父进程的某个子进程因收到信号而停止（暂停运行）或恢复时，内核也可能向父进程发送该信号。 

利用 SIGCHLD 信号实现监视回收子进程

```c
static void wait_child(int sig)
{
	/* 替子进程收尸 */
	while (waitpid(-1, NULL, WNOHANG) > 0)	// 非阻塞轮询方式
		continue;
}

int main(void)
{
	struct sigaction sig = {0};
	/* 为 SIGCHLD 信号绑定处理函数 */
	sigemptyset(sig.sa_mask);
	sig.sa_handler = wait_child;
	sig.sa_flags = 0;
	sigaction(SIGCHLD, &sig, NULL)
	
	switch(fork())
	{
		case -1:
			...
		case 0:
			_exit(0);
		default:
			break;
	}
}
```

### 执行新程序

系统调用 execve()可以将新程序加载到某一进程的内存空间，通过调用 execve()函数将一个外部的可执行文件加载到进程的内存空间运行，使用新的程序替换旧的程序，而进程的栈、数据、以及堆数据会被新程序的相应部件所替换，然后从新程序的 main()函数开始执行。

```
#include <unistd.h>

int execve(const char *filename, char *const argv[], char *const envp[]);
filename:载入程序文件路径
argv：指定了传递给新程序的命令行参数。是一个字符串数组，是由字符串指针所组成的数组，以 NULL 结束。
envp：参数 envp 也是一个字符串指针数组， 指定了新程序的环境变量列表
返回值：成功 不会返回  失败返回-1
```

```c
int main(int argc, char *argv[])
{
	char *arg_arr[5];
    char *env_arr[5] = {"NAME=app", "AGE=25", "SEX=man", NULL};
    
    arg_arr[0] = argv[1];
    arg_arr[1] = "Hello";
    arg_arr[2] = "World";
    arg_arr[3] = NULL;
    execve(argv[1], arg_arr, env_arr);
}
```

------

**exec 库函数**

```
#include <unistd.h>
extern char **environ;

int execl(const char *path, const char *arg, ... /* (char *) NULL */);
int execlp(const char *file, const char *arg, ... /* (char *) NULL */);
int execle(const char *path, const char *arg, ... /*, (char *) NULL, char * const envp[] */);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execvpe(const char *file, char *const argv[], char *const envp[]);

path:允许只提供新程序文件名，系统会在 PATH 所指定的目录列表中寻找相应的可执行文件
e: 可以指定自定义的环境变量列表给新程序
```

```c
// execv 传参
char *arg_arr[5];

arg_arr[0] = "./newApp";
arg_arr[1] = "Hello";
arg_arr[2] = "World";
arg_arr[3] = NULL;
execv("./newApp", arg_arr);

// execl 传参
execl("./newApp", "./newApp", "Hello", "World", NULL);
```

**system() **

在我们的程序当中执行任意 shell 命令 

```
#include <stdlib.h>

int system(const char *command);
```

## 进程状态

就绪、运行、僵尸、阻塞（浅睡眠、深睡眠）、暂停

- 就绪态 ：指该进程满足被 CPU 调度的所有条件但此时并没有被调度执行，只要得到 CPU就能够直接运行 
- 运行态 ：指该进程当前正在被 CPU 调度运行，处于就绪态的进程得到 CPU 调度就会进入运行态； 
- 僵尸态 ：指该进程已经结束、但其父进程还未给它“收尸”； 
- 可中断睡眠状态：“浅层睡眠” 表示睡的不够“死”，还可以被唤醒，一般来说可以通过信号来唤醒； 
- 不可中断睡眠状态："深度睡眠" 深度睡眠无法被信号唤醒，只能等待相应的条件成立才能结束睡眠状态。 、

把浅度睡眠和深度睡眠统称为等待态（或者叫阻塞态） 表示进程处于一种等待状态，等待某种条件成立之后便会进入到就绪态； 

- 暂停态： 暂停并不是进程的终止，表示进程暂停运行，一般可通过信号将进程暂停， 

![1682501961172](https://raw.githubusercontent.com/LQF376/Linux-arm-mystudy/main/markdown_pic/1682501961172.png)

### 进程关系

无关系（相互独立）、父子进程关系、进程组、会话

**进程组**

- 每个进程必定属于某一个进程组、且只能属于一个进程组；
- 每一个进程组有一个组长进程，组长进程的 ID 就等于进程组 ID； 
- 在组长进程的 ID 前面加上一个负号即是操作进程组； 
- 组长进程不能再创建新的进程组； 
- 只要进程组中还存在一个进程，则该进程组就存在，这与其组长进程是否终止无关； 
- 一个进程组可以包含一个或多个进程，进程组的生命周期从被创建开始，到其内所有进程终止或离开该进程组； 
- 默认情况下，新创建的进程会继承父进程的进程组 ID。 

```
#include <unistd.h>

pid_t getpgid(pid_t pid);		// 获取进程组ID
pid_t getpgrp(void);
pid: 0表示获取调用者进程的进程组ID
返回值： 成功 返回进程组ID 失败 -1

```

```
#include <unistd.h>

int setpgid(pid_t pid, pid_t pgid);	// 将参数 pid 指定的进程的进程组 ID 设置为参数 gpid
	pid: =0,使用调用者的进程ID
	pgid：=0，参数 pid 指定的进程作为进程组组长进程。
int setpgrp(void);	// 创建一个新的进程组

```

**会话**

会话是一个或多个进程组的集合；但只能有一个前台进程组，其它的是后台进程组； 每个会话都有一个会话首领（leader），即创建会话的进程。 一个会话可以有控制终端、也可没有控制终端 ；

会话的首领进程连接一个终端之后，该终端就成为会话的控制终端，与控制终端建立连接的会话首领进程被称为控制进程； 产生在终端上的输入和信号将发送给会话的前台进程组中的所有进程 

会话的首领进程的进程组 ID 将作为该会话的标识，也就是会话 ID（sid） 

```
#include <unistd.h>

pid_t getsid(pid_t pid);	// 获取进程的会话 ID
pid：0表示返回调用者进程的会话ID

```

如果调用者进程不是进程组的组长进程，调用 setsid()将创建一个新的会话，调用者进程是新会话的首领进程，同样也是一个新的进程组的组长进程，调用 setsid()创建的会话将没有控制终端 

```
#include <unistd.h>

pid_t setsid(void);		// 创建一个会话
返回值： 成功 新会话的会话ID 失败 -1

```

**守护进程（精灵进程 ）**

是运行在后台的一种特殊进程，它独立于控制终端并且周期性地执行某种任务或等待处理某些事情的发生

- 长期运行；守护进程是一种生存期很长的一种进程，它们一般在系统启动时开始运行，除非强行终止，否则直到系统关机都会保持运行。  
- 与控制终端脱离 ；脱离终端并且在后台运行， 脱离终端的目的是为了避免进程在运行的过程中的信息在终端显示并且进程也不会被任何终端所产生的信息所打断。 

进程名后面带有 d 就表示它是一个守护进程 ；守护进程自成进程组、自成会话，即 pid=gid=sid。 

### 编写守护进程

1. 创建子进程、终止父进程 
   - 保证了子进程不是一个进程组的组长进程 
2. 子进程调用 setsid 创建会话 
   - 子进程成为新会话的首领进程，同样也创建了新的进程组、子进程成为组长进程，此时创建的会话将没有控制终端。  
3. 将工作目录更改为根目录 
   - 在进程运行中，当前目录所在的文件系统是不能卸载的 ;让“/”作为守护进程的当前目录 
4. 重设文件权限掩码 umask 
   - 把文件权限掩码设置为 0， 确保进程有最大操作权限、这样可以大大增强该守护进程的灵活性。 
5. 关闭不再需要的文件描述符 
6. 将文件描述符号为 0、 1、 2 定位到/dev/null 
7. 其它：忽略 SIGCHLD 信号 

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <signal.h>
int main(void)
{
	pid_t pid;
	int i;
	
	/* 创建子进程 */
	pid = fork();
	if (0 > pid) 
	{
		perror("fork error");
		exit(-1);
	}
	else if (0 < pid)//父进程
        exit(0); //直接退出
    
    /* 1.创建新的会话、脱离控制终端 */
	if (0 > setsid()) {
		perror("setsid error");
		exit(-1);
	}
	/* 2.设置当前工作目录为根目录 */
	if (0 > chdir("/")) {
		perror("chdir error");
		exit(-1);
	}
	/* 3.重设文件权限掩码 umask */
	umask(0);
	/* 4.关闭所有文件描述符 */
	for (i = 0; i < sysconf(_SC_OPEN_MAX); i++)
		close(i);
	/* 5.将文件描述符号为 0、 1、 2 定位到/dev/null */
	open("/dev/null", O_RDWR);
	dup(0);
	dup(0);
	/* 6.忽略 SIGCHLD 信号 */
	signal(SIGCHLD, SIG_IGN);
	/* 正式进入到守护进程 */
	for ( ; ; ) {
		sleep(1);
		puts("守护进程运行中......");
	}
	exit(0);
}

```

**SIGHUP 信号 **

当用户准备退出会话时， 系统向该会话发出 SIGHUP 信号，会话将 SIGHUP 信号发送给所有子进程，子进程接收到 SIGHUP 信号后，便会自动终止，当所有会话中的所有进程都退出时，会话也就终止了；(信号默认处理方式是终止进程)

忽略了 SIGHUP 信号，导致该进程不会终止，所以会话也依然会存在

### 文件锁实现

通过一个特定的文件来实现，当程序启动之后，首先打开该文件，调用 open 时一般使用 O_WRONLY | O_CREAT 标志，当文件不存在则创建该文件，然后尝试去获取文件锁，若是成功，则将程序的进程号（PID）写入到该文件中，写入后不要关闭文件或解锁（释放文件锁） ，保证进程一直持有该文件锁；若是程序获取锁失败，代表程序已经被运行、则退出本次启动。
Tips：当程序退出或文件关闭之后，文件锁会自动解锁！ 
